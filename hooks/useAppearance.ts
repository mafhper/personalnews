import { useCallback } from 'react';
import { useLocalStorage } from './useLocalStorage';
import type { HeaderConfig, ContentConfig, LayoutPreset, BackgroundConfig } from '../types';
import { useExtendedTheme } from './useExtendedTheme';
import { DEFAULT_CONFIG } from '../services/auraWallpaperService';
import { BUILT_LAYOUT_PRESETS } from '../config/layoutPresets.config';

const defaultHeaderConfig: HeaderConfig = {
  style: 'default',
  position: 'floating',
  height: 'compact',
  showTitle: false,
  showLogo: true,
  customTitle: 'Personal News',
  logoUrl: null,
  logoSize: 'md',
  logoColorMode: 'original',
  syncFavicon: true,
  // Appearance defaults
  backgroundColor: '#1F1F1F',
  backgroundOpacity: 60,
  blurIntensity: 'heavy',
  borderColor: '#ffffff',
  borderOpacity: 8,
  categoryBackgroundColor: '#ffffff',
  categoryBackgroundOpacity: 3,
  // New props
  bgColor: '#1F1F1F',
  bgOpacity: 0.6,
  blur: 20,
};

const defaultContentConfig: ContentConfig = {
  showAuthor: true,
  showDate: true,
  showTime: false,
  showTags: true,
  layoutMode: 'modern',
  density: 'comfortable',
  paginationType: 'numbered',
};

const defaultBackgroundConfig: BackgroundConfig = {
  type: 'aura',
  value: '', // Will be generated by BackgroundCreator
  auraSettings: DEFAULT_CONFIG,
};

// Layout presets agora vêm do arquivo de configuração centralizado
// Edite config/layoutPresets.config.ts para ajustar os presets
export const LAYOUT_PRESETS: LayoutPreset[] = BUILT_LAYOUT_PRESETS;

interface UserOverrides {
  header?: Partial<HeaderConfig>;
  content?: Partial<ContentConfig>;
}

export const useAppearance = () => {
  const { themeSettings, updateThemeSettings, currentTheme, customThemes, defaultPresets, setCurrentTheme, removeCustomTheme } = useExtendedTheme();

  const [headerConfig, setHeaderConfig] = useLocalStorage<HeaderConfig>(
    'appearance-header',
    defaultHeaderConfig
  );

  const [contentConfig, setContentConfig] = useLocalStorage<ContentConfig>(
    'appearance-content',
    defaultContentConfig
  );

  const [backgroundConfig, setBackgroundConfig] = useLocalStorage<BackgroundConfig>(
    'appearance-background',
    defaultBackgroundConfig
  );

  const [activeLayoutId, setActiveLayoutId] = useLocalStorage<string | null>(
    'appearance-active-layout',
    'modern'
  );

  // Store user manual overrides to ensure they take precedence over presets
  const [userOverrides, setUserOverrides] = useLocalStorage<UserOverrides>(
    'appearance-overrides',
    {}
  );

  const updateHeaderConfig = useCallback((updates: Partial<HeaderConfig>, persistOverride: boolean = true) => {
    setHeaderConfig((prev) => ({ ...prev, ...updates }));
    if (persistOverride) {
      setActiveLayoutId(null);
      // Save manual override with safe merging
      setUserOverrides((prev) => {
        const currentOverrides = prev || {};
        return {
          ...currentOverrides,
          header: {
            ...(currentOverrides.header || {}),
            ...updates
          }
        };
      });
    }
  }, [setHeaderConfig, setUserOverrides, setActiveLayoutId]);

  const updateContentConfig = useCallback((updates: Partial<ContentConfig>, persistOverride: boolean = true) => {
    setContentConfig((prev) => ({ ...prev, ...updates }));
    if (persistOverride) {
      setActiveLayoutId(null);
      // Save manual override with safe merging
      setUserOverrides((prev) => {
        const currentOverrides = prev || {};
        return {
          ...currentOverrides,
          content: {
            ...(currentOverrides.content || {}),
            ...updates
          }
        };
      });
    }
  }, [setContentConfig, setUserOverrides, setActiveLayoutId]);

  const updateBackgroundConfig = useCallback((updates: Partial<BackgroundConfig>) => {
    setBackgroundConfig((prev) => ({ ...prev, ...updates }));
  }, [setBackgroundConfig]);

  // Clear user overrides - useful for resetting to pure preset state
  const clearUserOverrides = useCallback(() => {
    setUserOverrides({});
  }, [setUserOverrides]);

  /**
   * Apply a layout preset.
   * 
   * IMPORTANT: As per user requirement, switching layouts should ONLY affect
   * the page content (below navigation), NOT the header configuration.
   * Header settings are managed separately in Settings.
   * 
   * @param presetId - ID of the layout preset to apply
   * @param persist - Whether to persist this as the active layout
   * @param clearContentOverrides - Whether to clear content overrides (default: true)
   */
  const applyLayoutPreset = useCallback((presetId: string, persist: boolean = true, clearContentOverrides: boolean = true) => {
    const preset = LAYOUT_PRESETS.find(p => p.id === presetId);
    if (preset) {
      console.log(`Applying layout preset: ${presetId} (persist: ${persist})`, {
        presetContent: preset.content
      });

      // IMPORTANT: Preserve header overrides! User configured these in Settings.
      // Only clear content overrides to prevent layout settings from bleeding.
      if (clearContentOverrides) {
        setUserOverrides((prev) => ({
          ...prev,
          content: {} // Clear only content overrides, preserve header
        }));
      }

      // Apply content preset values
      // Content is the only thing that changes when switching layouts
      const contentOverrides = clearContentOverrides ? {} : (userOverrides?.content || {});

      const mergedContent = {
        ...defaultContentConfig,
        ...preset.content,
        ...contentOverrides
      };

      // Only update content, NOT header
      setContentConfig(mergedContent);

      if (persist) {
        setActiveLayoutId(presetId);
      }
    }
  }, [setContentConfig, setActiveLayoutId, userOverrides, setUserOverrides]);

  const refreshAppearance = useCallback(() => {
    // Re-applies the current configuration based on active preset and user overrides.
    // Useful to clear temporary overrides (like category-specific headers).
    const headerOverrides = userOverrides?.header || {};
    const contentOverrides = userOverrides?.content || {};

    if (activeLayoutId) {
      const preset = LAYOUT_PRESETS.find(p => p.id === activeLayoutId);
      if (preset) {
        const mergedHeader = {
          ...defaultHeaderConfig,
          ...preset.header,
          ...headerOverrides
        };
        const mergedContent = {
          ...defaultContentConfig,
          ...preset.content,
          ...contentOverrides
        };
        setHeaderConfig(mergedHeader);
        setContentConfig(mergedContent);
        return;
      }
    }

    // Fallback or Custom mode: Just re-apply overrides over defaults/current
    // This ensures temporary changes are wiped if they aren't in overrides
    const mergedHeader = { ...headerConfig, ...headerOverrides };
    // Note: if headerConfig is dirty from temp changes, this might not clear it if overrides doesn't touch those keys.
    // To strictly clear temp changes, we should rebuild from a clean state if possible.
    // But we don't have a "clean state" stored other than defaultHeaderConfig.
    // If activeLayoutId is null, we assume user manually configured everything, so current headerConfig IS the source of truth mostly.
    // However, for the specific case of "category override", we want to revert.
    // If we are in custom mode, maybe we can't easily revert without losing manual unsaved changes?
    // But manual changes SHOULD be in userOverrides if they were made via settings.
    // So:
    const cleanHeader = { ...defaultHeaderConfig, ...headerConfig, ...headerOverrides };
    // Wait, spread order: default -> current (dirty) -> overrides. Dirty wins if not in overrides.
    // We want: default -> preset (if any) -> overrides.

    if (!activeLayoutId) {
      // If custom, we accept 'headerConfig' is the state. 
      // But if 'headerConfig' has a temp change... we can't distinguish it from a permanent custom change made before overrides existed?
      // Actually, updateHeaderConfig persists to overrides. So ALL permanent changes are in overrides.
      // So we can rebuild from default + overrides.
      const rebuiltHeader = { ...defaultHeaderConfig, ...headerOverrides };
      // But wait, defaults might not match what the user had before the temp change if they started from a preset and then modified it?
      // If they modified it, it went to overrides.
      // So yes, default + overrides should be safe IF overrides captures everything.
      // But overrides only captures partials.
      // If I start with "Brutalist" (Logo: false). Set activeLayoutId = null.
      // Overrides = {}.
      // User enables Logo. Overrides = { Logo: true }.
      // Rebuilt = Default (Logo: true) + { Logo: true } -> Logo true.
      // But what about other Brutalist props? (Height: spacious).
      // Default has Height: compact.
      // Rebuilt will have Height: compact. User loses Brutalist base.

      // CONCLUSION: We cannot easily rebuild custom state without a base preset.
      // BUT, we only need to fix the "Category Override" issue.
      // Category override uses `persistOverride: false`.
      // So it updates `headerConfig` but NOT `userOverrides`.
      // If we want to undo it, we need to know what to go back to.

      // Best approach: `applyLayoutPreset` works fine. 
      // If `activeLayoutId` is present, `refreshAppearance` works perfectly.
      // If `activeLayoutId` is NULL, we are in trouble.
      // Workaround: Only support resetting category overrides if a preset is active.
      // OR, just re-apply the current `activeLayoutId` if it exists.

      if (activeLayoutId) {
        applyLayoutPreset(activeLayoutId);
      }
    }
  }, [activeLayoutId, applyLayoutPreset, headerConfig, contentConfig, userOverrides, setHeaderConfig, setContentConfig]);

  const resetAppearance = useCallback(() => {
    setHeaderConfig(defaultHeaderConfig);
    setContentConfig(defaultContentConfig);
    setBackgroundConfig(defaultBackgroundConfig);
    setActiveLayoutId(null);
    setUserOverrides({}); // Clear overrides on reset
  }, [setHeaderConfig, setContentConfig, setBackgroundConfig, setActiveLayoutId, setUserOverrides]);

  return {
    headerConfig,
    contentConfig,
    backgroundConfig,
    activeLayoutId,
    updateHeaderConfig,
    updateContentConfig,
    updateBackgroundConfig,
    applyLayoutPreset,
    resetAppearance,
    clearUserOverrides,
    themeSettings,
    updateThemeSettings,
    currentTheme,
    customThemes,
    defaultPresets,
    setCurrentTheme,
    removeCustomTheme,
    refreshAppearance,
  };
};
