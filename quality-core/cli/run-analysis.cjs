/**
 * Analysis Report Generator CLI
 * Generates reports for bundle size and dependency inventory.
 */
const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process')
const UI = require('./ui-helpers.cjs')
const History = require('./history.cjs')
const { refreshDashboardCache } = require('./dashboard-cache.cjs')

const args = process.argv.slice(2)
const isQuiet = args.includes('--quiet') || args.includes('-q')
const isSilent = args.includes('--silent') || args.includes('-s')
const modeLabel = [
  isSilent ? 'silent' : isQuiet ? 'quiet' : 'default',
].join('-')

const executionLog = {
  startTime: Date.now(),
  errors: [],
  warnings: [],
  reports: [],
}

const _rawLog = console.log.bind(console)
const _rawError = console.error.bind(console)

if (isSilent) {
  const originalLog = console.log
  const originalError = console.error
  console.log = (msg, ...rest) => {
    if (typeof msg === 'string' && msg.includes('ERROR')) {
      executionLog.errors.push(msg)
      originalLog(`[ERROR] ${msg}`, ...rest)
    } else if (typeof msg === 'string' && msg.includes('INFO')) {
      return
    } else {
      originalLog(msg, ...rest)
    }
  }
  console.error = (msg, ...rest) => {
    executionLog.errors.push(msg)
    originalError(`[ERROR] ${msg}`, ...rest)
  }
} else if (isQuiet) {
  console.log = (msg, ...rest) => {
    if (typeof msg === 'string' && msg.startsWith('[ANALYSIS - INFO]')) return
    _rawLog(msg, ...rest)
  }
}

const BundleAnalysisAudit = require('../packages/audits/bundle-analysis.cjs')
const DEFAULT_THRESHOLDS = require('../packages/core/thresholds.cjs')

const ANALYSIS_DIR = path.join(process.cwd(), 'performance-reports', 'analysis')
const DIST_DIR = path.join(process.cwd(), 'dist')

function getSafeFilePath(filename) {
  const resolvedPath = path.resolve(ANALYSIS_DIR, filename)
  const resolvedAnalysisDir = path.resolve(ANALYSIS_DIR)

  if (!resolvedPath.startsWith(resolvedAnalysisDir)) {
    throw new Error(`Invalid filename: ${filename} - path traversal detected`)
  }

  return resolvedPath
}

if (!fs.existsSync(ANALYSIS_DIR)) {
  fs.mkdirSync(ANALYSIS_DIR, { recursive: true })
}

function saveJsonReport(filename, data) {
  const filepath = getSafeFilePath(filename)
  fs.writeFileSync(filepath, JSON.stringify(data, null, 2))
  console.log(`[ANALYSIS - INFO] JSON report saved: ${filepath}`)
  return filepath
}

function generateMarkdownReport(results) {
  const date = new Date().toLocaleString()
  const commit = getGitCommit()

  let md = `# Bundle and Build Analysis\n\n`
  md += `**Date:** ${date}\n`
  md += `**Commit:** \`${commit}\`\n\n`

  if (results.bundle) {
    md += `## Bundle Analysis\n\n`
    md += `| Metric | Value |\n`
    md += `| :--- | :--- |\n`
    md += `| Total JS Size | ${results.bundle.metrics.jsTotalKb.toFixed(2)} KB |\n`
    md += `| Total CSS Size | ${results.bundle.metrics.cssTotalKb.toFixed(2)} KB |\n`
    md += `| Total Bundle Size | ${results.bundle.metrics.bundleTotalKb.toFixed(2)} KB |\n`
    md += `| Largest Chunk | ${results.bundle.metrics.largestChunk.name} (${results.bundle.metrics.largestChunk.sizeKb.toFixed(2)} KB) |\n`
    md += `| Total Files | ${results.bundle.metrics.fileCount} |\n`
    md += `| JS Files | ${results.bundle.metrics.jsFileCount} |\n`
    md += `| CSS Files | ${results.bundle.metrics.cssFileCount} |\n`
    md += `| Assets | ${results.bundle.metrics.assetsCount} |\n\n`

    if (results.bundle.details?.chunks?.length > 0) {
      md += `### Largest Files\n\n`
      md += `| File | Type | Size (KB) |\n`
      md += `| :--- | :--- | :--- |\n`
      for (const chunk of results.bundle.details.chunks.slice(0, 10)) {
        md += `| ${chunk.name} | ${chunk.type.toUpperCase()} | ${chunk.size.toFixed(2)} |\n`
      }
      md += `\n`
    }

    if (results.bundle.violations?.length > 0) {
      md += `### Warnings\n\n`
      for (const v of results.bundle.violations) {
        md += `- **${v.metric}**: ${v.value} (threshold: ${v.threshold})\n`
      }
      md += `\n`
    } else {
      md += `### No Warnings\n\n`
      md += `Bundle is within defined limits.\n\n`
    }
  }

  if (results.dependencies) {
    md += `## Dependency Analysis\n\n`
    md += `| Metric | Value |\n`
    md += `| :--- | :--- |\n`
    md += `| Total Dependencies | ${results.dependencies.total || 'N/A'} |\n`
    md += `| Production Dependencies | ${results.dependencies.production || 'N/A'} |\n`
    md += `| Development Dependencies | ${results.dependencies.development || 'N/A'} |\n\n`
  }

  md += `---\n*Generated by Quality Core - Analysis Module*\n`

  return md
}

function getGitCommit() {
  try {
    return execSync('git rev-parse --short HEAD', { encoding: 'utf-8' }).trim()
  } catch {
    return 'unknown'
  }
}

function analyzeDependencies() {
  try {
    const pkg = JSON.parse(
      fs.readFileSync(path.join(process.cwd(), 'package.json'), 'utf-8')
    )

    const deps = Object.keys(pkg.dependencies || {})
    const devDeps = Object.keys(pkg.devDependencies || {})

    return {
      total: deps.length + devDeps.length,
      production: deps.length,
      development: devDeps.length,
      productionList: deps,
      developmentList: devDeps,
    }
  } catch (err) {
    console.error('[ANALYSIS - ERROR] Failed to analyze dependencies:', err.message)
    return null
  }
}

async function runAnalysis() {
  const historyKey = 'analysis'
  let stopTimer = null
  if (!isSilent) {
    UI.printHeader({
      title: 'QUALITY CORE - ANALYSIS',
      modes: ['--silent', '--quiet'],
      active: [
        isSilent ? 'silent' : null,
        isQuiet ? 'quiet' : null,
      ].filter(Boolean),
    })
    const avgHeader = History.getAverageDuration(historyKey, modeLabel)
    stopTimer = UI.printTimingHeader({
      avgLabel: avgHeader,
      modeLabel,
      live: UI.shouldLiveTimer() && !isQuiet,
    })
  }
  if (!isSilent && !isQuiet) {
    UI.printScriptStart('analysis', 1, 1)
  } else if (isQuiet) {
    UI.printQuietStepStart('analysis', 1, 1)
  }
  console.log('[ANALYSIS - INFO] Starting analysis...')
  console.log(`[ANALYSIS - INFO] Output directory: ${ANALYSIS_DIR}`)

  const timestamp = Date.now()
  const results = {
    meta: {
      timestamp,
      commit: getGitCommit(),
      project: 'personal-news',
    },
  }

  console.log('[ANALYSIS - INFO] Running bundle analysis...')
  try {
    const bundleResult = await BundleAnalysisAudit.run({
      distDir: DIST_DIR,
      thresholds: DEFAULT_THRESHOLDS,
    })
    results.bundle = bundleResult
    console.log(
      `[ANALYSIS - INFO] Bundle total: ${bundleResult.metrics.bundleTotalKb.toFixed(2)} KB`
    )
  } catch (err) {
    console.error('[ANALYSIS - ERROR] Bundle analysis failed:', err.message)
    results.bundle = { error: err.message }
  }

  console.log('[ANALYSIS - INFO] Analyzing dependencies...')
  results.dependencies = analyzeDependencies()
  if (results.dependencies) {
    console.log(
      `[ANALYSIS - INFO] Found ${results.dependencies.total} dependencies`
    )
  }

  const jsonFilename = `analysis-${timestamp}.json`
  saveJsonReport(jsonFilename, results)

  saveJsonReport('analysis-latest.json', results)

  const mdContent = generateMarkdownReport(results)
  const mdFilename = `analysis-${timestamp}.md`
  const mdFilepath = getSafeFilePath(mdFilename)
  fs.writeFileSync(mdFilepath, mdContent)
  console.log(`[ANALYSIS - INFO] Markdown report saved: ${mdFilepath}`)

  const latestMdPath = getSafeFilePath('analysis-latest.md')
  fs.writeFileSync(latestMdPath, mdContent)

  console.log('[ANALYSIS - INFO] Analysis complete!')
  console.log(`[ANALYSIS - INFO] Reports saved to: ${ANALYSIS_DIR}`)

  const durationMs = Date.now() - executionLog.startTime
  History.saveExecutionTime('analysis', durationMs, modeLabel)
  const avg = History.getAverageDuration('analysis', modeLabel)
  if (!isSilent && !isQuiet) {
    UI.printScriptEnd('analysis', durationMs, avg, executionLog.errors.length === 0)
  } else if (isQuiet) {
    UI.printQuietStepEnd('analysis', 1, 1, durationMs, avg, executionLog.errors.length === 0)
  }
  if (stopTimer) stopTimer()

  if (isSilent) {
    const metrics = []
    if (results.bundle && !results.bundle.error) {
      metrics.push(
        `Bundle: ${results.bundle.metrics.bundleTotalKb.toFixed(2)} KB`
      )
    } else if (results.bundle && results.bundle.error) {
      metrics.push(`Bundle analysis: ${results.bundle.error}`)
    }

    if (results.dependencies) {
      metrics.push(`Dependencies: ${results.dependencies.total}`)
    }

    const duration = (durationMs / 1000).toFixed(2)
    const status = executionLog.errors.length > 0 ? 'fail' : 'pass'

    UI.printSummary({
      title: 'ANALYSIS',
      status,
      metrics,
      errors: executionLog.errors,
      warnings: executionLog.warnings,
      duration,
      reportDir: ANALYSIS_DIR,
    })
  }

  await refreshDashboardCache({ silent: isSilent || isQuiet })
  return results
}

if (require.main === module) {
  runAnalysis().catch(err => {
    _rawError('[ANALYSIS - ERROR] Analysis failed:', err)
    if (isSilent) {
      executionLog.errors.push(err.message)
      const durationMs = Date.now() - executionLog.startTime
      const duration = (durationMs / 1000).toFixed(2)
      History.saveExecutionTime('analysis', durationMs, modeLabel)
      UI.printSummary({
        title: 'ANALYSIS',
        status: 'fail',
        errors: executionLog.errors,
        duration,
        reportDir: ANALYSIS_DIR,
      })
    } else {
      const durationMs = Date.now() - executionLog.startTime
      History.saveExecutionTime('analysis', durationMs, modeLabel)
      const avg = History.getAverageDuration('analysis', modeLabel)
      UI.printScriptEnd('analysis', durationMs, avg, false)
    }
    process.exit(1)
  })
}

module.exports = { runAnalysis }
